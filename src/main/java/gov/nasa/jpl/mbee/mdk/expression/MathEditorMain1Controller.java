package gov.nasa.jpl.mbee.mdk.expression;

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.StringReader;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.antlr.v4.runtime.tree.ParseTree;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;

import com.nomagic.magicdraw.openapi.uml.SessionManager;
import com.nomagic.uml2.ext.magicdraw.classes.mdkernel.Constraint;
import com.nomagic.uml2.ext.magicdraw.classes.mdkernel.Element;
import com.nomagic.uml2.ext.magicdraw.classes.mdkernel.Property;
import com.nomagic.uml2.ext.magicdraw.classes.mdkernel.ValueSpecification;

import antlr.gov.nasa.jpl.mbee.mdk.expression.AsciiMathML2TreeTestxx.XX;
import net.sourceforge.jeuclid.LayoutContext;
import net.sourceforge.jeuclid.context.LayoutContextImpl;
import net.sourceforge.jeuclid.context.Parameter;
import net.sourceforge.jeuclid.converter.Converter;



public class MathEditorMain1Controller implements ActionListener {
	
	private static boolean DEBUG = true;
	private MathEditorMain1Model model;
	private MathEditorMain1Controller controller;
	private MathEditorMain1  view;
	private ActionListener libraryButtonActionListener;
	
	private ListModelOperands operandsListModel;
	private ListModelOperations operationsListModel;
	
	public MathEditorMain1Controller(SelectedConstraintBlock _selectedConstraintBlock, Constraint _currentConstraint){
		
		model = new MathEditorMain1Model(_selectedConstraintBlock, _currentConstraint);
		controller = this;
		
		libraryButtonActionListener = ( event -> { //Updating Operations by asking a user to select asciiMathLibraryBlock and CustomFunction
				//when "Libraries..." button is pressed.
				LibrarySelector ls = new LibrarySelector();
				if(ls.openDialog()){
					model.setOperationAndCustromFunctions();
				}
				updateOperationsListModel(); //updating view's operations
			}
		);
	}
	public void showView() 
	{
		EventQueue.invokeLater(() -> {
				try {
					operandsListModel = new ListModelOperands(model.getOperands());
					operationsListModel = new ListModelOperations(model.getCombinedOperations());
					
					view = new MathEditorMain1(controller, operandsListModel, operationsListModel);	//with list selection
					view.initialize();
					
					//AutoComplete in the expression.  The suggestion only contains operands and custom functions.
					List<String> words = model.getOperandsInString();
					words.addAll(model.getCustomOperationsInString());
					new AutoCompleteJTextField( view.getTextField(), words);
					view.displayExpression(model.getEditExpression(), model.isStringExpression(), model.getName());
					
				} catch (Exception e) {
					e.printStackTrace();
				}
		});
	} 
	private void updateOperationsListModel(){
		this.operationsListModel.reset(model.getCombinedOperations());
	}
	public ActionListener getLibraryButtonActionListener() { return this.libraryButtonActionListener;} 
	
	public Element getConstraintBlock(){
		return model.getConstraintBlock();
	}
	public Element getCombinedOperation(String _operationString){
		return model.getCombinedOperation(_operationString);
	}
	public Element getOperand(String _operandString){
		return model.getOperand(_operandString);
	}
	public void addOperand(Property _newOperand){
		this.operandsListModel.add(_newOperand);
	}
	public void setName(String _name){
		this.model.setCurrentConstraintName(_name);
	}
	public void actionPerformed(ActionEvent e) {
		
		if ( SessionManager.getInstance().isSessionCreated())
			SessionManager.getInstance().closeSession();
		SessionManager.getInstance().createSession(e.getActionCommand());
		
		//action for confirm button
		if ( e.getActionCommand() == MathEditorMain1.CONFIRM){
			
			String textExpression = view.getTextExpression();
			if ( textExpression.compareTo(this.model.getEditExpression()) != 0){
		
				//save name in case it changed
				saveConstraintName();
				
				ValueSpecification vs;
				ValueSpecification originalvs = this.model.currentConstraint.getSpecification();
				
				Tree2UMLExpression t2uml = null;
				if(view.selectedRadioButton() == MathEditorMain1.RadioButton.PREFIX){	//PARSE IN PREFIX NOTATION
			
					AsciiMathML2Tree a2t = new AsciiMathML2Tree(textExpression);
					ParseTree pt = null;
					try {
						pt = a2t.parse();
						if ( DEBUG)	a2t.showTree();	//shows the LISP tree generated by an
					}
					catch (Exception pe){
						//parsing failed.
						Tree2UMLExpression.showMessage("Error: Problem in expression for prefix.");
						return;
					}
					
					t2uml = new Tree2UMLExpression_Prefix(controller, pt, originalvs);
					try {
						vs = t2uml.parse();
					} catch (Exception e2) {
						Tree2UMLExpression.showMessage("Error: Problem in expression for prefix.");
						return;
					}	
					AsciiMathParser amp = new AsciiMathParser();
					Document docExp = amp.parseAsciiMath(textExpression/*, opt*/);
					render(docExp, false);
						
					if(!t2uml.getError()){
						vs.setOwner(this.model.currentConstraint);
					}
	
				} 
				else if ( view.selectedRadioButton() == MathEditorMain1.RadioButton.INFIX){
					//**************************RENDER EXPRESSION************************
					//optional to be included in AsciiMathParser.parseAsciiMath method to include annotataion of orinal expression
					//AsciiMathParserOptions opt = new AsciiMathParserOptions();
			    	//opt.setAddSourceAnnotation(true);
	
					AsciiMathParser amp = new AsciiMathParser();
					Document docExp = amp.parseAsciiMath(textExpression/*, opt*/);
					
					if ( DEBUG ) {String x = XX.printXML(docExp);	
								  System.out.println(x);}
					
					DocPreprocess p = new DocPreprocess(docExp);
					docExp = p.process();
					if ( DEBUG ) {String x = XX.printXML(docExp);	
					  System.out.println(x);}
	
					
					Doc2InfixString gg = new Doc2InfixString(controller, docExp);
			    	try {
						vs = gg.traverse0(null);
						Exp2StringExp transE2SE = new Exp2StringExp(vs);
						ValueSpecification vsNew = transE2SE.transform();
						vsNew.setOwner(this.model.currentConstraint);
						render(docExp, false);
						
					} catch (Exception e2) {
						// TODO Auto-generated catch block
						e2.printStackTrace();	
						Tree2UMLExpression.showMessage("Error: " + e2.getMessage());
						
				        try 
				        {  
				        	docExp.getFirstChild().appendChild(createMrowMessage(docExp, "(Invalid)"));
				            render(docExp, true);
				        } catch (Exception ee) {  
				        	ee.printStackTrace();
				        } 
					}
				}
					//save name in case it changed
				saveConstraintName();
			}
			else 
				javax.swing.JOptionPane.showMessageDialog(null, "Expression not changed!");
			
		}
		else if ( e.getActionCommand() == MathEditorMain1.nameButton.EDIT.buttonName()){ //press edit button for name
			this.view.setNameFileldEditable(true);
			this.view.setButtonName(MathEditorMain1.nameButton.SAVE.buttonName());
		}
		else if ( e.getActionCommand() == MathEditorMain1.nameButton.SAVE.buttonName()){ //press save button for name
			saveConstraintName();
		}
		SessionManager.getInstance().closeSession();
	}
	private org.w3c.dom.Element createMrowMessage(Document docExp, String mrowMessage){
		 
		char c[]  = mrowMessage.toCharArray();
		org.w3c.dom.Element mrow = docExp.createElement("mrow");
		org.w3c.dom.Element mi0 = null;
		for (int i = 0; i < c.length; i++){
			 mi0 = docExp.createElement("mi");
			 mi0.appendChild(docExp.createTextNode(new String(c)));
		}
		mrow.appendChild(mi0);
		return mrow;
	}
	
	
	private void render(Document docExp, boolean isError) {
		Converter getPic = Converter.getInstance();
		LayoutContextImpl l = (LayoutContextImpl) LayoutContextImpl.getDefaultLayoutContext();
		l.setParameter(Parameter.MATHSIZE, 30);
		if ( isError)
			l.setParameter(Parameter.MATHCOLOR, Color.RED);
		else
			l.setParameter(Parameter.MATHCOLOR, Color.BLACK);
		BufferedImage pic;
		try {
			pic = getPic.render(docExp, (LayoutContext) l);	//LayoutContextImpl.getDefaultLayoutContext());
			view.setLblRenderIcon(pic);
			view.setTextExpressionCaretNotVisible();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
	}
	private void saveConstraintName(){
		this.model.setCurrentConstraintName(view.getName());
		this.view.setButtonName(MathEditorMain1.nameButton.EDIT.buttonName());
		this.view.setNameFileldEditable(false);
	}
	
}
